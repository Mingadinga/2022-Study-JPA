## 2. 양방향 연관관계
* 팀에서도 회원을 접근 가능하게
* 객체 관점 :: 팀의 관점에서 회원과의 관계는 일대다 -> 일대다(1:N)은 여러 건과 연관관계 맺음 -> 컬렉션 사용(List)
* 테이블 관점 :: 디비 테이블은 외래 키 하나로 양방향 접근 가능. 추가할 필요 없음
![image](https://user-images.githubusercontent.com/68958749/170649229-76ea7046-8631-407d-9209-8eb4841e1734.png)

```java
//Team Entity
...
@OneToMany(mappedBy="team")
private List<Member> members = new ArrayList<Member>(); // List 컬렉션 사용
```
1. @OneToMany
* 일대다 관계 매핑을 해주는 어노테이션
* mappdeBy속성은 양방향 매핑시 사용하는 속성. name값을 반대쪽 매핑의 필드 이름값으로 매칭(여기선 team)
  
  -> '연관관계 주인'과 관련
```java
Team team = em.find(Team.class, "team1");
List<Member> members = team.getMembers(); // 팀 -> 회원 객체 그래프 탐색
// member.getUsername() 출력
```
### 1. 연관관계 주인
* 객체에는 '양방향 연관관계'가 존재하지 않는다.
* 서로 다른 단방향 연관관계 2개를 양방향 처럼 보이게 만든 것뿐!
* 객체 :: 회원 -> 팀 + 팀 -> 회원
* 테이블 :: 회원 <-> 팀
#### 양방향 연관관계의 엔티티는 참조가 2개 필요한데 외래 키는 하나. 그럼 어떤 관계를 사용해서 외래 키를 관리해야 하느냐?
#### == 연관관계의 주인을 정하자

#### 1-1. 연관관계의 주인
* 연관관계의 주인은 양방향 매핑 시 지켜야할 규칙
* 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록, 수정, 삭제) 할 수 있음
* 주인이 아닌 쪽은 읽기만 가능
1. 연관관계의 주인은 mappedBy속성을 사용 안함
2. 주인이 아닌 곳이 mappedBy속성을 사용하여 연관관계 주인 지정

#### 1-2. 연관관계의 주인은 외래 키가 있는 곳
연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 함
* 여기선 회원 테이블이 외래 키(TEAM_ID)를 가지고 있으므로 Member.team이 주인이 되는 것
```java
위의 코드와 동일
@OneToMany(mappedBy="team") // 연관관계의 주인은 Member.team이라고 알려줌
```
![image](https://user-images.githubusercontent.com/68958749/170652395-776d991f-91f5-47f9-8a65-954b79ae8246.png)



