# 1장. JPA 소개

**요약**

SQL을 직접 다루면 코드가 쿼리에 의존적이게 된다. 또 RDB와 객체지향의 목적이 다르기 때문에, 객체를 저장할 때 개발자가 개입하여 매핑 작업을 해야하므로 작성해야 하는 코드가 늘어나고, 복잡성이 증가하면 코드로 제어하기가 매우 어려워진다. JPA를 사용하여 SQL 의존을 끊어 개발자는 객체 지향 프로그래밍에 집중할 수 있게 된다. 

**목차**

1. 애플리케이션이 SQL을 직접 다룰 때 발생하는 문제 - JPA의 문제 해결
2. 패러다임 불일치
3. JPA가 각 문제를 어떻게 해결하는가
4. JPA는 무엇이고 JPA를 사용하는 이유는 무엇인가


## SQL을 애플리케이션에서 직접 다룰 때의 문제점

DB는 객체 구조와 다른 데이터 중심 구조를 가지므로, 객체를 DB에 직접 저장하거나 조회할 수 없다. 
따라서 개발자가 객체 지향과 DB 중간에서 SQL과 JDBC API를 사용해 변환 작업을 해야 한다. 
하지만 여전히 SQL과 엔티티 객체는 논리적으로 강한 의존 관계를 가진다. 
무슨 말이나면 DAO에 작성된 SQL을 보고 어떤 객체들이 조회하는지 구분해서 사용해야 한다. 
개발자들이 엔티티를 신뢰하며 사용할 수 없다. (DAO에 사용하는 SQL에 문제가 있을 가능성을 배제할 수 없다) 
또한, 요구사항이 변경되면 DAO의 CRUD 코드와 SQL 대부분을 변경해야 한다. 
**SQL에 의존적인 개발을 해야하므로 매우 수고롭고 버그 발생 가능성도 높으며 객체 지향적인 개발에 집중하기 어렵다.**

### JPA의 문제 해결

JPA를 사용하면 객체를 DB에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하는 거이 아니라 JPA가 제공하는 API를 사용하면 된다. 
그러면 JPA가 개발자 대신에 적절한 SQL을 생성해서 DB에 전달한다.

**저장 기능**

1. JPA가 객체와 매핑 정보를 확인한다.
2. 적절한 INSERT SQL을 생성해서 DB에 전달한다.

```java
jpa.persist(member);
```

**조회 기능**

1. JPA가 객체와 매핑 정보를 확인한다.
2. 적절한 SELECT SQL을 생성해서 DB에 전달한다.

```java
String memberId = "helloId";
Member member = jpa.find(Member.class, memberId);
```

**수정 기능**

- JPA는 별도의 수정 메소드를 제공하지 않는다.
- 대신 객체를 조회해서 값을 변경하면 트랜잭션이 커밋될 때 DB에 적절한 UPDATE SQL이 전달된다. (영속성 컨텍스트)

```java
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경");
```

**연관된 객체 조회**

- 연관 객체(Team)을 사용하는 시점에 적절한 SELECT SQL을 실행한다. (프록시와 연관관계 관리)

```java
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam();
```

## 패러다임의 불일치

애플리케이션은 발전하면서 그 내부의 복잡성도 점점 커진다. 지속 가능한 애플리케이션을 개발하는 일은 끊임없이 증가하는 복잡성과의 싸움이다. 객체 지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 복잡성을 제어하는 다양한 장치를 제공한다. 그래서 현대의 복잡한 애플리케이션은 대부분 객체 지향 언어로 개발한다.

문제는 객체 지향적으로 정의한 도메인 모델을 영구 보관할 때 발생한다. 객체가 단순하면 객체의 모든 속성을 꺼내서 파일이나 데이터베이스에 저장하면 되지만, 부모 객체를 상속받았거나 다른 객체를 참조하고 있다면 객체의 상태를 저장하기 어렵다. 데이터를 영구적으로 보관하기 위해 가장 많이 사용되는 관계형 데이터베이스는 데이터 중심으로 구조화되어 있고 집합적인 사고를 요구한다. 객체 지향의 추상화, 상속, 다형성 같은 개념은 없다.

이렇게 객체와 관계형 DB는 목적이 다르므로 둘의 기능과 표현 방법도 다르다. 이것을 객체와 관계형 DB의 패러다임 불일치 문제라고 한다. 이 문제 때문에 객체 구조를 테이블 구조에 저장하는 데에는 한계가 있다. 이 문제를 개발자가 중간에서 해결하는데, 앞에서 보았다 싶이 너무 많은 시간과 코드를 소비해야 한다. 패러다임의 불일치로 인해 발생하는 문제와 JPA를 통한 해결책을 알아보자.

### 상속

- 상황 : Item 객체를 상속받은 Album 객체를 DB에 저장하려고 한다.
- 문제 : SQL을 작성하는 방식으로 개발하면, ITEM 테이블과 ALBUM 테이블에 접근하는 두개의 INSERT SQL을 작성해야 한다. 자식 타입도 지정해주어야 한다. 조회하려면 조인 쿼리를 작성해야 한다. 객체 하나 저장하는데 작성해야 하는 쿼리가 점점 많아진다.
- 해결 : JPA는 상속과 관련된 패러다임 불일치 문제를 해결해준다. 개발자는 마치 **자바 컬렉션에 객체를 저장하듯이** JPA에게 객체를 저장하면 된다.

```java
// 저장
jpa.persist(album);
// 실행되는 SQL
INSERT INTO ITEM ...
INSERT INTO ALBUM ...
```

```java
// 조회
String albumid = "id100";
**Album album = jpa.find(Album.class, albumId);**
// 실행되는 SQL
SELECT I.*, A.*
	FROM ITEM I
	JOIN INTO A ON I.ITEM_ID = A.ITEM_ID
```

### 연관관계

- 문제 : 객체는 참조를 사용해 연관 객체를 조회하고, 테이블은 외래 키를 사용해 다른 테이블과 연관관계를 가지고 조인을 사용해 연관된 테이블을 조회한다. 개발자가 중간에서 변환 역할을 해야 한다. 연관 관계를 객체를 생성하려면, 각 객체를 생성하고 연관관계를 설정한 뒤 반환해주어야 한다.
- 해결 : JPA는 연관관계와 관련된 패러다임 불일치 문제를 해결한다.
    
    ```java
    // 저장
    **member.setTeam(team);**  // 회원과 팀 연관관계 설정
    jpa.persist(member);   // team의 참조를 외래키로 변환해서 적절한 INSERT 쿼리를 전달
    ```
    
    ```java
    // 조회
    Member member = jpa.find(Member.class, memberId);
    Team team = **member.getTeam();**
    ```
    

### 객체 그래프 탐색

- 문제 : 객체는 연관관계가 설정된 객체들끼리 자유롭게 탐색할 수 있어야 한다. 이를 객체 그래프 탐색이라고 한다. SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다. 비즈니스 로직에 따라 사용하는 객체 그래프가 다른데 언제 끊어질지 모를 객체 그래프를 함부로 탐색할 수 없다. 객체지향 개발자에게는 큰 제약이다. 모든 객체 그래프를 탐색하는 쿼리를 만드는 것은 현실적이지 않고, 결국 조회 범위를 어디까지 설정하느냐에 따라 메소드를 여러 벌 만들어서 사용해야 한다.
    
    ```java
    Member member = memberDAO.find(memberId);  // SQL이 어떤 객체를 조회하는지 확인 필요
    member.getTeam();  // 이거 됨?
    member.getOrder().getDelivery(); // 얘도 돼??
    ```
    
- 해결 : JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있다. JPA는 연관 객체를 사용하는 시점에 적절한 쿼리를 실행하므로, 연관된 객체를 신뢰하고 마음껏 조회할 수 없다. (NPE 안 터지겠다) 이 기능을 지연 로딩이라고 한다.
    
    ```java
    class Member{
    	private Order order;
    	public Order getOrder(){
    		return order;
    	}
    }
    ..
    Member member = jpa.find(Member.class, memberId);
    **Order order = member.getOrder();**
    order.getOrderDate(); // Order를 사용하는 시점에 SELECT 실행. 신뢰하고 사용
    ```
    

### 비교

- 문제 : 데이터베이스는 기본 키의 값으로 row를 구분한다. 반면 객체는 동일성 비교(주소값)와 동등성 비교(객체 내부 값)를 사용한다. 그래서 DB의 같은 로우를 조회해도 객체의 동일성 비교에는 실패한다. 이 문제를 해결하기 위해 DB의 같은 로우를 조회할 때마다 같은 인스턴스를 반환하도록 구현하는 것은 어렵다. 여기에 여러 트랜잭션이 동시에 실행되는 상황이면 문제는 더 어렵다.
    
    ```java
    String memberId = "100";
    Member member1 = memberDAO.getMember(memberId);
    Member member2 = memberDAO.getMember(memberId);
    member1==member2; // 다르다
    ```
    
- 해결 : JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다. JPA를 사용하는 코드는 동일성 비교에 성공한다.
    
    ```java
    String memberId = "100";
    Member member1 = jpa.find(Member.class, memberId);
    Member member2 = memberDAO.getMember(Member.class, memberId);
    member1==member2; // 다르다
    ```
    

## JPA는 무엇이고 JPA를 사용하는 이유는 무엇인가

### ORM, 하이버네이트, JPA의 관계

ORM은 객체와 관계형 DB를 매핑한다는 뜻이다. ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임 불일치 문제를 개발자 대신 해결한다. 자바 진영에서 가장 많이 사용되는 ORM 프레임워크는 하이버네이트 프레임워크이다. 하이버네이트를 기반으로 새로운 자바 ORM 기술 표준이 만들어지는데 이것이 바로 JPA이다. **JPA는 자바 ORM 기술에 대한 API 표준 명세이고, 이를 구현한 ORM 프레임워크 중 가장 대중적인 것이 하이버네이트**이다.

### JPA 사용의 장점

1. 생산성 : 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달한다. SQL을 작성할 필요가 없게 된다. DB 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.
2. 유지 보수 : 필드 변경이 생겨도 JPA가 관련 쿼리를 알아서 생성해주므로 수정해야할 코드가 줄어든다.
3. 패러다임의 불일치 해결 : 상속, 연관관게, 객체 그래프 탐색, 비교 등과 같은 문제를 해결해준다. 코드로 제어하면 유지보수에도 좋지 않고 제어가 어렵다.
4. 애플리케이션과 DB 사이의 계층
    1. 최적화 시도 가능
    2. 애플리케이션이 특정 DB 기술에 종속되지 않는다
